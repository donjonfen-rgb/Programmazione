Common Design: Use Tail Pointer

Very common pattern:

typedef struct {
    t_node *tail;
} CircularList;


Why?

Because:

tail->next = head


So:

head = tail->next

Insert at front = O(1)

Insert at back = O(1)

âž• Insert at End (Efficient Version)
void insert(CircularList *list, int value)
{
    t_node *newt_node = malloc(sizeof(*newt_node));
    if (!newt_node) return;

    newt_node->value = value;

    if (list->tail == NULL) {
        newt_node->next = newt_node;  // points to itself
        list->tail = newt_node;
    } else {
        newt_node->next = list->tail->next;
        list->tail->next = newt_node;
        list->tail = newt_node;
    }
}

ðŸ—‘ Deleting Entire List

You must break the cycle first or carefully loop:

t_node *head = list->tail->next;
t_node *current = head;

do {
    t_node *temp = current;
    current = current->next;
    free(temp);
} while (current != head);


Then:

list->tail = NULL;

ðŸ“Œ When Are Circular Lists Useful?

Round-robin scheduling

Multiplayer turn systems

Ring buffers

Josephus problem

Music playlist loop

Embedded systems task rotation

âš ï¸ Common Bugs

Infinite loops (forgetting stop condition)

Losing head reference

Deleting the only node (special case!)

Corrupting tail->next

Traversing with while(current) â†’ infinite loop

ðŸ”¥ Senior Advice

If you use circular lists:

Always maintain a strong invariant (tail->next == head)

Always handle single-node case separately

Prefer storing tail, not head

If you want, I can next explain:

Circular doubly linked list

Sentinel node circular list (cleanest design)

How circular lists make t_queues simpler

Or walk through full implementation step-by-step

de \*current = head; if (current != NULL) { do { printf("%d ", current->value); current = current->next; } while (current != head); }

isn't there another condition instead of resolving to use the do while?

Yes â€” you donâ€™t have to use do-while. Itâ€™s just the cleanest for circular lists.

Here are the correct alternatives and when to use them.

âœ… Option 1 â€” while with First-Iteration Handling
t_node *current = head;

if (current != NULL) {
    printf("%d ", current->value);
    current = current->next;

    while (current != head) {
        printf("%d ", current->value);
        current = current->next;
    }
}


This works, but you manually handle the first node.

Thatâ€™s why do-while is cleaner.

âœ… Option 2 â€” Infinite Loop + Break
t_node *current = head;

if (current != NULL) {
    while (1) {
        printf("%d ", current->value);
        current = current->next;

        if (current == head)
            break;
    }
}


Very explicit. Sometimes clearer in production systems code.

âœ… Option 3 â€” Using Tail Instead of Head (Cleaner Design)

If you store tail, then:

head = tail->next


Traversal:

if (list->tail != NULL) {
    t_node *head = list->tail->next;
    t_node *current = head;

    while (1) {
        printf("%d ", current->value);
        if (current == list->tail)
            break;
        current = current->next;
    }
}


This avoids comparing against head repeatedly.

ðŸš« What DOESNâ€™T Work
while (current != NULL)


This never stops in a circular list.

ðŸ”¥ Why do-while Is Idiomatic

Because circular lists:

Always want to process the starting node

Stop when we come back

Have no natural NULL terminator

do-while expresses that perfectly.

ðŸ§  Senior-Level Rule

If your structure has:

No NULL terminator

Guaranteed non-null start (after check)

â†’ do-while is often the correct semantic loop.

If you want, I can show how to write a traversal that:

Works for both circular and non-circular lists

Or avoids head comparison entirely

Or handles deletion during traversal safely