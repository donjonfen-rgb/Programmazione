1ï¸âƒ£ Understand exactly what fgets / get_next_line must do

At a conceptual level, your function must:

Read from a file descriptor

Return one line at a time

Stop at \n or EOF

Remember leftover data between calls

Work even if:

Lines are longer than your buffer

read() returns partial data

Multiple calls are made in a row

This â€œrememberingâ€ part is the heart of the project.

2ï¸âƒ£ You must understand read() deeply

If you donâ€™t fully understand read(), stop and do that first.

You need to know:

read(fd, buf, BUFFER_SIZE) can return:

> 0 â†’ bytes read

0 â†’ EOF

-1 â†’ error

It does not null-terminate

It can return less than BUFFER_SIZE

It can return data without a newline

ğŸ”¥ Biggest mistake: assuming read() behaves nicely.

3ï¸âƒ£ Static variables (this is non-negotiable)

You must understand:

static char *stash;


It keeps data between function calls

Lives for the entire program runtime

Must be manually freed at the right time

If you donâ€™t manage the stash correctly:

Memory leaks

Segfaults

Wrong output

4ï¸âƒ£ Memory management will make or break you

You need to be solid with:

malloc, free

Avoiding:

Double free

Use-after-free

Leaks

Realloc logic (usually manual via malloc + memcpy)

Expect to:

Join strings

Extract substrings

Keep leftovers

ğŸ’¡ Tip: every allocation must have one clear owner.

5ï¸âƒ£ String handling (without cheating)

Youâ€™ll likely re-implement helpers:

ft_strlen

ft_strchr

ft_strjoin

ft_substr

Make sure:

They handle NULL

They donâ€™t overread

They allocate correctly

Bad helper functions = impossible debugging later.

6ï¸âƒ£ Know the edge cases BEFORE coding

Write these down now:

Empty file

File without trailing \n

File with only \n

Very long line

BUFFER_SIZE = 1

Multiple calls after EOF

Invalid file descriptor

If you donâ€™t think about these early, your logic will fight you.

7ï¸âƒ£ Define your algorithm first (donâ€™t freestyle)

A solid high-level plan looks like this:

If stash contains \n

Extract line

Update stash

Return line

Else

Read into buffer

Append to stash

Repeat

If EOF

Return remaining stash (if any)

Clean up

Do not code before this logic is crystal clear.

8ï¸âƒ£ Decide early: single FD or multiple FDs

Some versions require handling multiple file descriptors.

That changes everything:

static char *stash âŒ

static char *stash[FD_MAX] âœ…

Know which one youâ€™re implementing.

9ï¸âƒ£ Debug like a pro

Before coding, prepare to use:

printf strategically

valgrind

Manual test files

Step-by-step tracing

You will have bugs. Thatâ€™s expected.

10ï¸âƒ£ What NOT to do

âŒ Donâ€™t assume newline comes in one read
âŒ Donâ€™t free stash too early
âŒ Donâ€™t return pointers to freed memory
âŒ Donâ€™t ignore EOF behavior

Minimal mental checklist before you start

Youâ€™re ready if you can answer yes to all of these:

Do I know how read() behaves?

Do I know how static variables work?

Can I manage heap memory confidently?

Do I know all required edge cases?

Do I have a clear algorithm?

If any answer is â€œehhhâ€ â€” pause and fix that first.